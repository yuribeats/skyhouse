<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ASCENSION PORTAL</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: 'Courier New', Courier, monospace;
      font-weight: 700;
      text-transform: uppercase;
    }

    body {
      background: #0000AA;
      color: #fff;
      min-height: 100vh;
      padding: 40px 20px;
    }

    .container {
      max-width: 600px;
      margin: 0 auto;
      position: relative;
      z-index: 1;
      opacity: 1 !important;
    }

    h1 {
      font-size: 32px;
      font-family: Arial, sans-serif;
      font-weight: 900;
      letter-spacing: 2px;
      margin-bottom: 40px;
      border-bottom: 2px solid #fff;
      padding-bottom: 12px;
      text-align: center;
      -webkit-text-stroke: 1.5px #fff;
      paint-order: stroke fill;
    }

    .step {
      display: none;
    }

    .step.active {
      display: block;
    }

    .step-label {
      font-size: 14px;
      color: #fff;
      margin-bottom: 24px;
      letter-spacing: 1px;
    }

    label {
      display: block;
      font-size: 12px;
      letter-spacing: 1px;
      margin-bottom: 8px;
      color: #fff;
    }

    .field {
      margin-bottom: 24px;
    }

    .help-icon {
      display: inline-block;
      width: 16px;
      height: 16px;
      border: 1px solid #fff;
      text-align: center;
      line-height: 16px;
      font-size: 10px;
      color: #fff;
      margin-left: 4px;
      vertical-align: middle;
    }

    .help-tooltip {
      display: none;
      margin-top: 8px;
      padding: 10px;
      border: 1px solid #5555FF;
      font-size: 11px;
      font-weight: 900;
      text-transform: uppercase;
      color: #fff;
      line-height: 1.6;
    }

    .help-tooltip.open {
      display: block;
    }

    input, textarea {
      caret-shape: block;
      caret-color: #fff;
    }

    /* Custom file drop zone */
    .drop-zone {
      border: 2px solid #5555FF;
      padding: 40px 20px;
      text-align: center;
      font-size: 14px;
      color: #fff;
      letter-spacing: 1px;
      position: relative;
      transition: border-color 0.2s;
    }

    .drop-zone.dragover {
      border-color: #228B22;
      color: #228B22;
    }

    .drop-zone.has-file {
      border-color: #228B22;
      color: #fff;
    }

    .drop-zone input[type="file"] {
      position: absolute;
      inset: 0;
      opacity: 0;
      width: 100%;
      height: 100%;
    }

    /* Custom textarea */
    textarea {
      width: 100%;
      background: #000055;
      border: 2px solid #5555FF;
      color: #fff;
      padding: 12px;
      font-size: 14px;
      font-family: 'Courier New', Courier, monospace;
      font-weight: 900;
      text-transform: uppercase;
      resize: vertical;
      min-height: 120px;
      outline: none;
    }

    textarea:focus {
      border-color: #228B22;
    }

    /* Custom text input */
    .text-input {
      width: 100%;
      background: #000055;
      border: 2px solid #5555FF;
      color: #fff;
      padding: 12px;
      font-size: 14px;
      font-family: 'Courier New', Courier, monospace;
      font-weight: 900;
      text-transform: uppercase;
      outline: none;
    }

    .text-input:focus {
      border-color: #228B22;
    }

    /* Custom dropdown */
    .dropdown {
      position: relative;
    }

    .dropdown-trigger {
      width: 100%;
      background: #000055;
      border: 2px solid #5555FF;
      color: #fff;
      padding: 12px;
      font-size: 14px;
      font-family: 'Courier New', Courier, monospace;
      font-weight: 900;
      text-transform: uppercase;
      text-align: left;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .dropdown-trigger .arrow {
      font-size: 10px;
      transition: transform 0.2s;
    }

    .dropdown.open .dropdown-trigger {
      border-color: #228B22;
    }

    .dropdown.open .dropdown-trigger .arrow {
      transform: rotate(180deg);
    }

    .dropdown-menu {
      display: none;
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: #000055;
      border: 2px solid #5555FF;
      border-top: none;
      max-height: 200px;
      overflow-y: auto;
      z-index: 10;
    }

    .dropdown.open .dropdown-menu {
      display: block;
    }

    .dropdown-item {
      padding: 12px;
      font-size: 13px;
      color: #fff;
      border-bottom: 1px solid #5555FF;
    }

    .dropdown-item:last-child {
      border-bottom: none;
    }

    .dropdown-item:hover {
      background: #0000CC;
    }

    .dropdown-item.selected {
      color: #228B22;
    }

    /* Name input */
    .name-input {
      width: 100%;
      background: #000055;
      border: 2px solid #5555FF;
      color: #fff;
      padding: 12px;
      font-size: 14px;
      font-family: 'Courier New', Courier, monospace;
      font-weight: 900;
      text-transform: uppercase;
      outline: none;
    }

    .name-input:focus {
      border-color: #228B22;
    }

    /* Buttons */
    .btn {
      background: #fff;
      color: #0000AA;
      border: none;
      padding: 14px 32px;
      font-size: 14px;
      font-family: 'Courier New', Courier, monospace;
      font-weight: 900;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    .btn:disabled {
      opacity: 1;
    }

    .btn-outline {
      background: transparent;
      color: #fff;
      border: 2px solid #fff;
      padding: 14px 32px;
      font-size: 14px;
      font-family: 'Courier New', Courier, monospace;
      font-weight: 900;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    .btn-row {
      display: flex;
      gap: 12px;
      margin-top: 32px;
    }

    /* Recipients list */
    .add-row {
      display: flex;
      gap: 8px;
    }

    .add-row .text-input {
      flex: 1;
    }

    .recipient-list {
      margin-top: 16px;
    }

    .recipient-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 0;
      border-bottom: 1px solid #5555FF;
      font-size: 13px;
      word-break: break-all;
    }

    .recipient-item .addr {
      flex: 1;
      margin-right: 12px;
    }

    .remove-btn {
      background: none;
      border: 1px solid #fff;
      color: #fff;
      padding: 4px 10px;
      font-size: 11px;
      font-family: 'Courier New', Courier, monospace;
      font-weight: 900;
      text-transform: uppercase;
    }

    .remove-btn:hover {
      border-color: #fff;
      color: #fff;
    }

    .recipient-count {
      font-size: 12px;
      color: #fff;
      margin-top: 8px;
    }

    /* Status */
    .status-list {
      list-style: none;
    }

    .status-list li {
      padding: 12px 0;
      border-bottom: 1px solid #5555FF;
      font-size: 14px;
      color: #fff;
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .status-list li.active {
      color: #fff;
    }

    .status-list li.done {
      color: #228B22;
    }

    .status-list li.error {
      color: #ff4444;
    }

    .spinner {
      width: 12px;
      height: 12px;
      border: 2px solid #5555FF;
      border-top-color: #fff;
      animation: spin 0.6s linear infinite;
      flex-shrink: 0;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .checkmark {
      color: #228B22;
      flex-shrink: 0;
      font-size: 14px;
    }

    .error-icon {
      color: #ff4444;
      flex-shrink: 0;
      font-size: 14px;
    }

    .error-message {
      margin-top: 20px;
      padding: 16px;
      border: 2px solid #ff4444;
      color: #ff4444;
      font-size: 13px;
      word-break: break-word;
    }

    .success-message {
      margin-top: 20px;
      padding: 16px;
      border: 2px solid #228B22;
      color: #228B22;
      font-size: 13px;
    }

    /* Gallery */
    .gallery-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px;
      margin-top: 20px;
    }

    .gallery-item {
      border: 2px solid #5555FF;
    }

    .gallery-item img {
      width: 100%;
      aspect-ratio: 1;
      object-fit: cover;
      display: block;
    }

    .gallery-item .gallery-info {
      padding: 10px;
      font-size: 11px;
      border-top: 1px solid #5555FF;
    }

    .gallery-item .gallery-name {
      color: #fff;
      margin-bottom: 4px;
    }

    .gallery-item .gallery-id {
      color: #fff;
    }

    .gallery-loading {
      color: #fff;
      font-size: 14px;
      padding: 20px 0;
    }

    /* Token detail */
    .token-image {
      width: 100%;
      display: block;
      border: 2px solid #5555FF;
    }

    .token-name {
      font-size: 20px;
      margin-top: 20px;
      margin-bottom: 8px;
    }

    .token-id {
      font-size: 12px;
      color: #fff;
      margin-bottom: 20px;
    }

    .token-description {
      font-size: 13px;
      font-weight: 900;
      text-transform: uppercase;
      line-height: 1.6;
      color: #fff;
      margin-bottom: 20px;
      white-space: pre-wrap;
    }

    .token-meta {
      border-top: 1px solid #5555FF;
      padding-top: 16px;
      margin-top: 16px;
    }

    .token-meta-row {
      display: flex;
      justify-content: space-between;
      padding: 8px 0;
      border-bottom: 1px solid #5555FF;
      font-size: 11px;
    }

    .token-meta-label {
      color: #fff;
    }

    .token-meta-value {
      color: #fff;
      word-break: break-all;
      text-align: right;
      max-width: 60%;
    }
    .grain-overlay {
      position: fixed;
      top: -50%; left: -50%;
      width: 200%; height: 200%;
      z-index: 0;
      pointer-events: none;
      opacity: 0.03;
      animation: grain 0.5s steps(1) infinite;
      background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)' opacity='1'/%3E%3C/svg%3E");
    }

    @keyframes grain {
      0% { transform: translate(0, 0); }
      10% { transform: translate(-5%, -10%); }
      20% { transform: translate(-15%, 5%); }
      30% { transform: translate(7%, -25%); }
      40% { transform: translate(-5%, 25%); }
      50% { transform: translate(-15%, 10%); }
      60% { transform: translate(15%, 0%); }
      70% { transform: translate(0%, 15%); }
      80% { transform: translate(3%, 35%); }
      90% { transform: translate(-10%, 10%); }
      100% { transform: translate(0, 0); }
    }

    @media (max-width: 640px) {
      body {
        padding: 20px 12px;
      }

      .container {
        max-width: 100%;
      }

      .text-input, .name-input, textarea, .dropdown-trigger {
        font-size: 16px;
        padding: 14px;
      }

      .btn, .btn-outline {
        font-size: 14px;
        padding: 16px 20px;
        width: 100%;
        text-align: center;
      }

      .btn-row {
        flex-direction: column;
        gap: 10px;
      }

      .add-row {
        flex-direction: column;
      }

      .add-row .btn {
        width: 100%;
      }

      .gallery-grid {
        grid-template-columns: 1fr;
        gap: 12px;
      }

      .recipient-item {
        font-size: 11px;
      }

      .token-meta-row {
        flex-direction: column;
        gap: 4px;
      }

      .token-meta-value {
        text-align: left;
        max-width: 100%;
      }

      .drop-zone {
        padding: 30px 12px;
      }
    }
  </style>
</head>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<body>
  <canvas id="meshCanvas" style="position:fixed; top:0; left:0; width:100%; height:100%; z-index:0; pointer-events:none;"></canvas>
  <div style="position:fixed; top:0; left:0; width:100vw; height:100vh; z-index:0; pointer-events:none; background:radial-gradient(ellipse at center, transparent 40%, rgba(0,0,100,0.7) 100%);"></div>
  <div class="grain-overlay"></div>
  <div class="container">

    <!-- STEP 0: LOGIN -->
    <div id="step0" class="step active">
      <div class="step-label">WELCOME TO THE ©ASCENSION SERVICES™ CORP.</div>

      <div class="field">
        <label>USERNAME</label>
        <input type="text" class="text-input" id="usernameInput" placeholder="INPROCESS USERNAME - MUST APPEAR EXACTLY AS IT DOES ON INPROCESS">
      </div>

      <div class="field">
        <label>API KEY <span class="help-icon" id="apiKeyHelp">?</span></label>
        <input type="text" class="text-input" id="apiKeyInput" placeholder="INPROCESS API KEY" style="text-transform: none;" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">
        <div class="help-tooltip" id="apiKeyTooltip">YOUR API KEY AUTHENTICATES MINTING ACTIONS ON INPROCESS. <a href="https://www.inprocess.world/manage/api-keys" target="_blank" style="color:#228B22; text-decoration:underline;">GET YOUR API KEY HERE</a></div>
      </div>

      <div id="authError" class="error-message" style="display:none"></div>

      <div class="btn-row">
        <button class="btn" id="loginBtn" style="display:none">CREATE TOKEN</button>
        <button class="btn-outline" id="galleryLoginBtn" style="display:none">GALLERY</button>
      </div>
    </div>

    <!-- STEP 1: UPLOAD -->
    <div id="step1" class="step">
      <div class="step-label">STEP 1 / UPLOAD</div>

      <div class="field">
        <label>IMAGE / VIDEO</label>
        <div class="drop-zone" id="dropZone">
          <span id="dropText">DROP FILE HERE OR CLICK TO SELECT</span>
          <input type="file" id="fileInput" accept="image/*,video/mp4">
        </div>
        <div id="uploadProgress" style="display:none; margin-top:8px; height:4px; border:1px solid #5555FF;">
          <div id="uploadProgressBar" style="height:100%; width:0%; background:#fff; transition:width 0.2s;"></div>
        </div>
        <div id="fileError" class="error-message" style="display:none"></div>
        <img id="imagePreview" style="display:none; max-width:100%; margin-top:12px; margin-left:auto; margin-right:auto;">
        <video id="videoPreview" style="display:none; max-width:100%; margin-top:12px; margin-left:auto; margin-right:auto;" controls muted></video>
      </div>

      <div class="field">
        <label>NAME</label>
        <input type="text" class="name-input" id="nameInput" placeholder="MOMENT NAME">
      </div>

      <div class="field">
        <label>DESCRIPTION</label>
        <textarea id="descInput" placeholder="DESCRIBE THIS MOMENT"></textarea>
      </div>

      <div class="field">
        <label>COLLECTION</label>
        <div class="dropdown" id="collectionDropdown">
          <div class="dropdown-trigger" id="collectionTrigger">
            <span id="collectionLabel">LOADING COLLECTIONS...</span>
            <span class="arrow">&#9660;</span>
          </div>
          <div class="dropdown-menu" id="collectionMenu"></div>
        </div>
      </div>

      <div class="btn-row">
        <button class="btn" id="nextBtn" disabled>NEXT</button>
      </div>
    </div>

    <!-- STEP 2: RECIPIENTS -->
    <div id="step2" class="step">
      <div class="step-label">STEP 2 / RECIPIENTS</div>

      <div class="field">
        <label>RECIPIENT 2</label>
        <div class="add-row">
          <input type="text" class="text-input" id="addrInput" placeholder="0X..." autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">
          <button class="btn" id="addAddrBtn">ADD</button>
        </div>
      </div>

      <div class="recipient-list">
        <div class="recipient-item"><span class="addr">CXY.ETH</span></div>
        <div id="recipient2Row"></div>
      </div>
      <div class="recipient-count" id="recipientCount"></div>

      <div class="btn-row">
        <button class="btn-outline" id="backBtn">BACK</button>
        <button class="btn" id="mintBtn" disabled>MINT</button>
      </div>
    </div>

    <!-- STEP 3: STATUS -->
    <div id="step3" class="step">
      <div class="step-label">STEP 3 / STATUS</div>

      <ul class="status-list" id="statusList">
        <li id="statusUpload">UPLOADING IMAGE TO ARWEAVE</li>
        <li id="statusMeta">UPLOADING METADATA TO ARWEAVE</li>
        <li id="statusMint">CREATING MOMENT</li>
        <li id="statusBreathe">BREATHE</li>
        <li id="statusAirdrop">AIRDROPPING TO RECIPIENTS</li>
      </ul>

      <div id="resultArea"></div>

      <div class="btn-row" id="resetRow" style="display:none">
        <button class="btn" id="resetBtn">MINT ANOTHER</button>
        <button class="btn-outline" id="galleryBtn">GALLERY</button>
      </div>
    </div>

    <!-- STEP 4: GALLERY -->
    <div id="step4" class="step">
      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:24px;">
        <div class="step-label" style="margin-bottom:0;">GALLERY</div>
        <button class="btn-outline" style="padding:8px 16px; font-size:12px;" onclick="showStep(galleryReturnStep)">BACK</button>
      </div>
      <div class="field">
        <div class="dropdown" id="galleryDropdown">
          <div class="dropdown-trigger" id="galleryTrigger">
            <span id="galleryDropLabel">ALL COLLECTIONS</span>
            <span class="arrow">&#9660;</span>
          </div>
          <div class="dropdown-menu" id="galleryMenu"></div>
        </div>
      </div>
      <div id="galleryContent" class="gallery-loading">LOADING TOKENS...</div>
      <div class="btn-row">
        <button class="btn-outline" id="galleryBackBtn">BACK</button>
      </div>
    </div>

    <!-- STEP 5: TOKEN DETAIL -->
    <div id="step5" class="step">
      <div class="step-label">TOKEN DETAIL</div>
      <div id="tokenDetail"></div>
      <div class="btn-row">
        <button class="btn-outline" id="tokenBackBtn">BACK</button>
      </div>
    </div>
  </div>

  <script>
    // State
    let artistUsername = null;
    let artistApiKey = null;
    let artistWallet = null;
    let selectedFile = null;
    let selectedFileData = null;
    let selectedCollection = null;
    let collections = [];
    const CXY_ADDR = '0x7b753919b953b1021a33f55671716dc13c1eae08';
    let recipients = [CXY_ADDR];

    // Elements
    const dropZone = document.getElementById('dropZone');
    const fileInput = document.getElementById('fileInput');
    const dropText = document.getElementById('dropText');
    const nameInput = document.getElementById('nameInput');
    const descInput = document.getElementById('descInput');
    const collectionDropdown = document.getElementById('collectionDropdown');
    const collectionTrigger = document.getElementById('collectionTrigger');
    const collectionLabel = document.getElementById('collectionLabel');
    const collectionMenu = document.getElementById('collectionMenu');
    const nextBtn = document.getElementById('nextBtn');
    const backBtn = document.getElementById('backBtn');
    const mintBtn = document.getElementById('mintBtn');
    const addrInput = document.getElementById('addrInput');
    const addAddrBtn = document.getElementById('addAddrBtn');
    const recipientList = document.getElementById('recipientList');
    const recipientCount = document.getElementById('recipientCount');
    const resetBtn = document.getElementById('resetBtn');
    const usernameInput = document.getElementById('usernameInput');
    const apiKeyInput = document.getElementById('apiKeyInput');
    const loginBtn = document.getElementById('loginBtn');
    const galleryLoginBtn = document.getElementById('galleryLoginBtn');
    const authError = document.getElementById('authError');

    // API key help toggle
    document.getElementById('apiKeyHelp').addEventListener('click', () => {
      document.getElementById('apiKeyTooltip').classList.toggle('open');
    });

    // Login validation
    function validateLogin() {
      const hasUsername = !!usernameInput.value.trim();
      const hasApiKey = !!apiKeyInput.value.trim();
      galleryLoginBtn.style.display = hasUsername ? '' : 'none';
      galleryLoginBtn.disabled = !hasUsername;
      loginBtn.style.display = hasApiKey ? '' : 'none';
      loginBtn.disabled = !(hasUsername && hasApiKey);
    }
    usernameInput.addEventListener('input', validateLogin);
    apiKeyInput.addEventListener('input', validateLogin);

    loginBtn.addEventListener('click', async () => {
      loginBtn.disabled = true;
      authError.style.display = 'none';

      artistUsername = usernameInput.value.trim().toLowerCase();
      artistApiKey = apiKeyInput.value.trim();
      showStep(1);
      loadCollections();
    });

    galleryLoginBtn.addEventListener('click', async () => {
      galleryLoginBtn.disabled = true;
      authError.style.display = 'none';

      artistUsername = usernameInput.value.trim().toLowerCase();
      artistApiKey = apiKeyInput.value.trim();
      galleryReturnStep = 0;
      gallerySelectedAddr = null;
      galleryDropLabel.textContent = 'ALL COLLECTIONS';
      showStep(4);
      galleryContent.className = 'gallery-loading';
      galleryContent.innerHTML = 'LOADING COLLECTIONS...';
      await loadCollections();
      buildGalleryDropdown();
      loadGallery();
    });

    // Steps
    const stepPaths = {
      0: '/process',
      1: '/process/upload',
      2: '/process/recipients',
      3: '/process/status',
      4: null,
      5: null
    };
    const pathToStep = Object.fromEntries(Object.entries(stepPaths).map(([k, v]) => [v, Number(k)]));

    function showStep(n, pushHistory) {
      document.querySelectorAll('.step').forEach(s => s.classList.remove('active'));
      document.getElementById('step' + n).classList.add('active');
      if (pushHistory !== false) {
        let path = stepPaths[n];
        if (n === 4 && artistWallet) {
          path = '/process/gallery/' + artistWallet;
        }
        if (path && location.pathname !== path) {
          history.pushState({ step: n }, '', path);
        }
      }
    }

    window.addEventListener('popstate', (e) => {
      const step = e.state?.step ?? 0;
      showStep(step, false);
    });

    // Validate step 1
    function validateStep1() {
      nextBtn.disabled = !(selectedFile && nameInput.value.trim() && descInput.value.trim() && selectedCollection);
    }

    // File handling
    dropZone.addEventListener('dragover', (e) => {
      e.preventDefault();
      dropZone.classList.add('dragover');
    });

    dropZone.addEventListener('dragleave', () => {
      dropZone.classList.remove('dragover');
    });

    dropZone.addEventListener('drop', (e) => {
      e.preventDefault();
      dropZone.classList.remove('dragover');
      if (e.dataTransfer.files.length) {
        handleFile(e.dataTransfer.files[0]);
      }
    });

    fileInput.addEventListener('change', () => {
      if (fileInput.files.length) {
        handleFile(fileInput.files[0]);
      }
    });

    function handleFile(file) {
      const isImage = file.type.startsWith('image/');
      const isVideo = file.type === 'video/mp4';
      const fileError = document.getElementById('fileError');
      const progressWrap = document.getElementById('uploadProgress');
      const progressBar = document.getElementById('uploadProgressBar');
      const imagePreview = document.getElementById('imagePreview');
      const videoPreview = document.getElementById('videoPreview');

      fileError.style.display = 'none';
      imagePreview.style.display = 'none';
      videoPreview.style.display = 'none';
      progressWrap.style.display = 'none';
      progressBar.style.width = '0%';

      if (!isImage && !isVideo) return;

      if (isVideo && file.size > 200 * 1024 * 1024) {
        fileError.textContent = 'VIDEO MUST BE UNDER 200MB';
        fileError.style.display = 'block';
        return;
      }

      selectedFile = file;
      progressWrap.style.display = 'block';

      const reader = new FileReader();
      reader.onprogress = (e) => {
        if (e.lengthComputable) {
          progressBar.style.width = Math.round((e.loaded / e.total) * 100) + '%';
        }
      };
      reader.onload = (e) => {
        selectedFileData = e.target.result;
        progressBar.style.width = '100%';

        dropText.textContent = file.name;
        dropZone.classList.add('has-file');

        if (isImage) {
          imagePreview.src = e.target.result;
          imagePreview.style.display = 'block';
        } else {
          videoPreview.src = URL.createObjectURL(file);
          videoPreview.style.display = 'block';
        }

        setTimeout(() => { progressWrap.style.display = 'none'; }, 500);
        validateStep1();
      };
      reader.readAsDataURL(file);
    }

    nameInput.addEventListener('input', validateStep1);
    descInput.addEventListener('input', validateStep1);

    // Collection dropdown
    collectionTrigger.addEventListener('click', () => {
      if (collections.length === 0) return;
      collectionDropdown.classList.toggle('open');
    });

    document.addEventListener('click', (e) => {
      if (!collectionDropdown.contains(e.target)) {
        collectionDropdown.classList.remove('open');
      }
    });

    async function loadCollections() {
      collectionLabel.textContent = 'LOADING COLLECTIONS...';
      try {
        const res = await fetch('/api/process/collections?username=' + encodeURIComponent(artistUsername));
        const data = await res.json();
        collections = Array.isArray(data) ? data : (data.collections || []);
        if (data.wallet) artistWallet = data.wallet;

        if (collections.length === 0) {
          collectionLabel.textContent = 'NO COLLECTIONS FOUND';
          return;
        }

        collectionLabel.textContent = 'SELECT COLLECTION';
        collectionMenu.innerHTML = '';

        collections.forEach((col, i) => {
          const item = document.createElement('div');
          item.className = 'dropdown-item';
          item.textContent = col.name || col.address || ('COLLECTION ' + (i + 1));
          item.addEventListener('click', () => {
            selectedCollection = col;
            collectionLabel.textContent = item.textContent;
            collectionMenu.querySelectorAll('.dropdown-item').forEach(d => d.classList.remove('selected'));
            item.classList.add('selected');
            collectionDropdown.classList.remove('open');
            validateStep1();
          });
          collectionMenu.appendChild(item);
        });
      } catch (err) {
        collectionLabel.textContent = 'ERROR LOADING COLLECTIONS';
      }
    }

    // Navigation
    nextBtn.addEventListener('click', () => { showStep(2); validateStep2(); });
    backBtn.addEventListener('click', () => showStep(1));

    // Recipients
    function validateStep2() {
      mintBtn.disabled = false;
      recipientCount.textContent = recipients.length + ' RECIPIENT' + (recipients.length > 1 ? 'S' : '');
    }

    function renderRecipients() {
      const r2 = document.getElementById('recipient2Row');
      r2.innerHTML = '';
      if (recipients.length > 1) {
        const item = document.createElement('div');
        item.className = 'recipient-item';
        const addrSpan = document.createElement('span');
        addrSpan.className = 'addr';
        addrSpan.textContent = recipients[1];
        const removeBtn = document.createElement('button');
        removeBtn.className = 'remove-btn';
        removeBtn.textContent = 'X';
        removeBtn.addEventListener('click', () => {
          recipients.splice(1, 1);
          renderRecipients();
          validateStep2();
        });
        item.appendChild(addrSpan);
        item.appendChild(removeBtn);
        r2.appendChild(item);
      }
      validateStep2();
    }

    function addRecipient() {
      if (recipients.length >= 2) return;
      const addr = addrInput.value.trim();
      if (!addr) return;
      if (!/^0x[a-fA-F0-9]{40}$/.test(addr)) {
        addrInput.style.borderColor = '#ff4444';
        return;
      }
      if (recipients.includes(addr.toLowerCase())) return;
      recipients.push(addr.toLowerCase());
      addrInput.value = '';
      addrInput.style.borderColor = '#000';
      renderRecipients();
    }

    addAddrBtn.addEventListener('click', addRecipient);
    addrInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') addRecipient();
      addrInput.style.borderColor = '#000';
    });

    // Mint flow
    mintBtn.addEventListener('click', startMint);

    function setStatus(id, state, extra) {
      const el = document.getElementById(id);
      el.className = '';

      const existingIcon = el.querySelector('.spinner, .checkmark, .error-icon');
      if (existingIcon) existingIcon.remove();

      if (state === 'active') {
        el.classList.add('active');
        const spinner = document.createElement('div');
        spinner.className = 'spinner';
        el.prepend(spinner);
      } else if (state === 'done') {
        el.classList.add('done');
        const check = document.createElement('span');
        check.className = 'checkmark';
        check.textContent = '\u2713';
        el.prepend(check);
      } else if (state === 'error') {
        el.classList.add('error');
        const icon = document.createElement('span');
        icon.className = 'error-icon';
        icon.textContent = '\u2717';
        el.prepend(icon);
      }
    }

    async function startMint() {
      showStep(3);

      const resultArea = document.getElementById('resultArea');
      const resetRow = document.getElementById('resetRow');
      resultArea.innerHTML = '';
      resetRow.style.display = 'none';

      // Reset all statuses
      ['statusUpload', 'statusMeta', 'statusMint', 'statusBreathe', 'statusAirdrop'].forEach(id => {
        const el = document.getElementById(id);
        el.className = '';
        const icon = el.querySelector('.spinner, .checkmark, .error-icon');
        if (icon) icon.remove();
      });

      try {
        // 1. Upload image to Arweave
        setStatus('statusUpload', 'active');
        const base64 = selectedFileData.split(',')[1];
        const uploadRes = await fetch('/api/process/upload', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            data: base64,
            contentType: selectedFile.type,
            filename: selectedFile.name,
            apiKey: artistApiKey,
          }),
        });

        if (!uploadRes.ok) {
          const err = await uploadRes.json();
          throw new Error('IMAGE UPLOAD FAILED: ' + (err.error || uploadRes.status));
        }

        const uploadData = await uploadRes.json();
        const imageUri = uploadData.uri || uploadData.url || ('ar://' + uploadData.id);
        setStatus('statusUpload', 'done');

        // 2. Upload metadata JSON to Arweave
        setStatus('statusMeta', 'active');
        const isVideo = selectedFile.type === 'video/mp4';
        const metadata = {
          name: nameInput.value.trim(),
          description: descInput.value.trim(),
          image: isVideo ? '' : imageUri,
        };
        if (isVideo) {
          metadata.animation_url = imageUri;
          metadata.content = { mime: 'video/mp4', uri: imageUri };
        }
        const metaBase64 = btoa(unescape(encodeURIComponent(JSON.stringify(metadata))));
        const metaRes = await fetch('/api/process/upload', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            data: metaBase64,
            contentType: 'application/json',
            filename: 'metadata.json',
            apiKey: artistApiKey,
          }),
        });

        if (!metaRes.ok) {
          const err = await metaRes.json();
          throw new Error('METADATA UPLOAD FAILED: ' + (err.error || metaRes.status));
        }

        const metaData = await metaRes.json();
        const momentUri = metaData.uri || metaData.url || ('ar://' + metaData.id);
        setStatus('statusMeta', 'done');

        // 3. Create moment
        setStatus('statusMint', 'active');
        const collectionAddress = selectedCollection.address || selectedCollection.contractAddress;
        const mintRes = await fetch('/api/process/mint', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            momentUri,
            collectionAddress,
            account: selectedCollection.default_admin?.address,
            recipientCount: recipients.length,
            apiKey: artistApiKey,
          }),
        });

        if (!mintRes.ok) {
          const err = await mintRes.json();
          throw new Error('MINT FAILED: ' + (err.error || mintRes.status));
        }

        const mintData = await mintRes.json();
        const tokenId = mintData.tokenId;
        const mintedCollectionAddress = mintData.contractAddress || collectionAddress;
        setStatus('statusMint', 'done');

        // Wait for mint tx to confirm on-chain
        setStatus('statusBreathe', 'active');
        await new Promise(resolve => {
          let seconds = 0;
          const el = document.getElementById('statusBreathe');
          const textNode = el.childNodes[el.childNodes.length - 1];
          const interval = setInterval(() => {
            seconds++;
            textNode.textContent = 'BREATHE ' + seconds + 'S';
          }, 1000);
          setTimeout(() => {
            clearInterval(interval);
            resolve();
          }, 5000);
        });
        setStatus('statusBreathe', 'done');

        // 4. Airdrop
        setStatus('statusAirdrop', 'active');
        document.getElementById('statusAirdrop').childNodes[document.getElementById('statusAirdrop').childNodes.length - 1].textContent =
          'AIRDROPPING TO ' + recipients.length + ' RECIPIENT' + (recipients.length > 1 ? 'S' : '');

        const airdropRes = await fetch('/api/process/airdrop', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            collectionAddress: mintedCollectionAddress,
            tokenId,
            recipients,
            account: selectedCollection.default_admin?.address,
            apiKey: artistApiKey,
          }),
        });

        if (!airdropRes.ok) {
          const err = await airdropRes.json();
          throw new Error('AIRDROP FAILED: ' + (err.error || airdropRes.status));
        }

        setStatus('statusAirdrop', 'done');

        resultArea.innerHTML = '<div class="success-message">MOMENT MINTED AND AIRDROPPED SUCCESSFULLY</div>';
        resetRow.style.display = 'flex';

      } catch (err) {
        // Mark the current active step as error
        ['statusUpload', 'statusMeta', 'statusMint', 'statusBreathe', 'statusAirdrop'].forEach(id => {
          const el = document.getElementById(id);
          if (el.classList.contains('active')) {
            setStatus(id, 'error');
          }
        });

        resultArea.innerHTML = '<div class="error-message">' + err.message + '</div>';
        resetRow.style.display = 'flex';
      }
    }

    // Reset
    resetBtn.addEventListener('click', () => {
      selectedFile = null;
      selectedFileData = null;
      selectedCollection = null;
      recipients = [CXY_ADDR];

      fileInput.value = '';
      nameInput.value = '';
      descInput.value = '';
      dropText.textContent = 'DROP FILE HERE OR CLICK TO SELECT';
      dropZone.classList.remove('has-file');
      document.getElementById('imagePreview').style.display = 'none';
      document.getElementById('videoPreview').style.display = 'none';
      document.getElementById('fileError').style.display = 'none';

      collectionLabel.textContent = 'SELECT COLLECTION';
      collectionMenu.innerHTML = '';

      recipientList.innerHTML = '';
      recipientCount.textContent = '';

      validateStep1();
      validateStep2();
      showStep(0);
      artistUsername = null;
      artistApiKey = null;
      artistWallet = null;
      usernameInput.value = '';
      apiKeyInput.value = '';
      authError.style.display = 'none';
      validateLogin();
    });

    // Gallery
    const galleryBtn = document.getElementById('galleryBtn');
    const galleryBackBtn = document.getElementById('galleryBackBtn');
    const galleryContent = document.getElementById('galleryContent');
    const galleryDropdown = document.getElementById('galleryDropdown');
    const galleryTrigger = document.getElementById('galleryTrigger');
    const galleryDropLabel = document.getElementById('galleryDropLabel');
    const galleryMenu = document.getElementById('galleryMenu');
    let galleryReturnStep = 3;
    let galleryTokens = [];
    let gallerySelectedAddr = null;

    galleryTrigger.addEventListener('click', () => {
      if (collections.length === 0) return;
      galleryDropdown.classList.toggle('open');
    });

    document.addEventListener('click', (e) => {
      if (!galleryDropdown.contains(e.target)) {
        galleryDropdown.classList.remove('open');
      }
    });

    function buildGalleryDropdown() {
      galleryMenu.innerHTML = '';
      const allItem = document.createElement('div');
      allItem.className = 'dropdown-item' + (gallerySelectedAddr === null ? ' selected' : '');
      allItem.textContent = 'ALL COLLECTIONS';
      allItem.addEventListener('click', () => {
        gallerySelectedAddr = null;
        galleryDropLabel.textContent = 'ALL COLLECTIONS';
        galleryMenu.querySelectorAll('.dropdown-item').forEach(d => d.classList.remove('selected'));
        allItem.classList.add('selected');
        galleryDropdown.classList.remove('open');
        loadGallery();
      });
      galleryMenu.appendChild(allItem);

      collections.forEach((col, i) => {
        const item = document.createElement('div');
        item.className = 'dropdown-item' + (gallerySelectedAddr === col.address ? ' selected' : '');
        item.textContent = col.name || col.address || ('COLLECTION ' + (i + 1));
        item.addEventListener('click', () => {
          gallerySelectedAddr = col.address;
          galleryDropLabel.textContent = item.textContent;
          galleryMenu.querySelectorAll('.dropdown-item').forEach(d => d.classList.remove('selected'));
          item.classList.add('selected');
          galleryDropdown.classList.remove('open');
          loadGallery();
        });
        galleryMenu.appendChild(item);
      });
    }

    async function loadGalleryForAddress(addr) {
      const res = await fetch('/api/process/gallery?address=' + encodeURIComponent(addr));
      const data = await res.json();
      return (data.tokens || []).map(t => ({ ...t, collectionAddress: addr }));
    }

    async function loadGallery() {
      galleryContent.className = 'gallery-loading';
      galleryContent.innerHTML = 'LOADING TOKENS...';

      try {
        let tokens = [];
        if (gallerySelectedAddr) {
          tokens = await loadGalleryForAddress(gallerySelectedAddr);
        } else {
          const fetches = collections.map(c => loadGalleryForAddress(c.address));
          const results = await Promise.all(fetches);
          for (const r of results) tokens.push(...r);
        }

        if (tokens.length === 0) {
          galleryContent.innerHTML = 'NO TOKENS FOUND';
          return;
        }

        galleryContent.className = 'gallery-grid';
        galleryContent.innerHTML = '';
        galleryTokens = tokens;

        tokens.forEach(t => {
          const item = document.createElement('div');
          item.className = 'gallery-item';
          const imageUrl = (t.image || '').replace('ar://', 'https://ar-io.net/');
          item.innerHTML =
            '<img src="' + imageUrl + '" onerror="this.style.display=\'none\'">' +
            '<div class="gallery-info">' +
              '<div class="gallery-name">' + (t.name || 'UNTITLED') + '</div>' +
              '<div class="gallery-id">TOKEN ' + t.tokenId + '</div>' +
            '</div>';
          item.addEventListener('click', () => showTokenDetail(t));
          galleryContent.appendChild(item);
        });
      } catch (err) {
        galleryContent.innerHTML = 'ERROR LOADING GALLERY';
      }
    }

    galleryBtn.addEventListener('click', () => {
      showStep(4);
      buildGalleryDropdown();
      gallerySelectedAddr = selectedCollection?.address || null;
      galleryDropLabel.textContent = gallerySelectedAddr ? (selectedCollection?.name || selectedCollection?.address) : 'ALL COLLECTIONS';
      loadGallery();
    });

    galleryBackBtn.addEventListener('click', () => showStep(galleryReturnStep));

    const tokenDetail = document.getElementById('tokenDetail');
    const tokenBackBtn = document.getElementById('tokenBackBtn');

    tokenBackBtn.addEventListener('click', () => showStep(4));

    function showTokenDetail(t) {
      const imageUrl = (t.image || '').replace('ar://', 'https://ar-io.net/');
      const animUrl = (t.animation_url || '').replace('ar://', 'https://ar-io.net/');
      const contentUri = t.content?.uri ? t.content.uri.replace('ar://', 'https://ar-io.net/') : '';
      const contentMime = t.content?.mime || '';

      let mediaHtml = '';
      if (contentMime.startsWith('video/') && contentUri) {
        mediaHtml = '<video src="' + contentUri + '" controls style="width:100%; border:2px solid #000;"></video>';
      } else if (contentMime.startsWith('audio/') && contentUri) {
        mediaHtml = '<img class="token-image" src="' + imageUrl + '" onerror="this.style.display=\'none\'">' +
          '<audio src="' + contentUri + '" controls style="width:100%; margin-top:12px;"></audio>';
      } else if (animUrl && !contentMime) {
        mediaHtml = '<img class="token-image" src="' + animUrl + '" onerror="this.src=\'' + imageUrl + '\'">';
      } else {
        mediaHtml = '<img class="token-image" src="' + imageUrl + '" onerror="this.style.display=\'none\'">';
      }

      let metaHtml = '<div class="token-meta">';
      metaHtml += '<div class="token-meta-row"><span class="token-meta-label">TOKEN ID</span><span class="token-meta-value">' + t.tokenId + '</span></div>';
      metaHtml += '<div class="token-meta-row"><span class="token-meta-label">COLLECTION</span><span class="token-meta-value">' + (selectedCollection?.name || selectedCollection?.address || '') + '</span></div>';
      if (t.uri) {
        metaHtml += '<div class="token-meta-row"><span class="token-meta-label">METADATA</span><span class="token-meta-value">' + t.uri + '</span></div>';
      }
      if (t.image) {
        metaHtml += '<div class="token-meta-row"><span class="token-meta-label">IMAGE</span><span class="token-meta-value">' + t.image + '</span></div>';
      }
      if (contentMime) {
        metaHtml += '<div class="token-meta-row"><span class="token-meta-label">CONTENT TYPE</span><span class="token-meta-value">' + contentMime + '</span></div>';
      }
      metaHtml += '</div>';

      tokenDetail.innerHTML =
        mediaHtml +
        '<div class="token-name">' + (t.name || 'UNTITLED') + '</div>' +
        '<div class="token-id">TOKEN ' + t.tokenId + '</div>' +
        '<div class="token-description">' + (t.description || '') + '</div>' +
        metaHtml;

      const tokenPath = '/process/token/' + (t.collectionAddress || selectedCollection?.address || '') + '/' + t.tokenId;
      document.querySelectorAll('.step').forEach(s => s.classList.remove('active'));
      document.getElementById('step5').classList.add('active');
      history.pushState({ step: 5, token: t }, '', tokenPath);
    }

    // Route on initial load
    (function() {
      const p = location.pathname;
      const initStep = pathToStep[p];
      if (initStep !== undefined && initStep !== 0) {
        showStep(0, false);
      } else if (p === '/process' || p === '/process/') {
        history.replaceState({ step: 0 }, '', '/process');
      }
    })();

  </script>
  <script>
    (function() {
      const PARTICLE_COUNT = 18000;
      const FIELD_SIZE = 35;
      const BG_COLOR = 0x0000AA;

      const COLOR_A = new THREE.Color(0x0000dd);
      const COLOR_B = new THREE.Color(0x5555ff);
      const COLOR_C = new THREE.Color(0xffffff);
      const COLOR_D = new THREE.Color(0x3333cc);

      const canvas = document.getElementById('meshCanvas');
      const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true, powerPreference: 'high-performance' });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setClearColor(BG_COLOR, 0);

      const scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(BG_COLOR, 0.016);

      const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
      camera.position.set(0, 0, 22);

      const mouse = { x: 0, y: 0, targetX: 0, targetY: 0 };
      document.addEventListener('mousemove', (e) => {
        mouse.targetX = (e.clientX / window.innerWidth) * 2 - 1;
        mouse.targetY = -(e.clientY / window.innerHeight) * 2 + 1;
      });

      // Wireframe sphere
      const sphereGeo = new THREE.SphereGeometry(6, 32, 32);
      const sphereMat = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true, transparent: true, opacity: 0.08 });
      const sphere = new THREE.Mesh(sphereGeo, sphereMat);
      scene.add(sphere);

      // Particles
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(PARTICLE_COUNT * 3);
      const colors = new Float32Array(PARTICLE_COUNT * 3);
      const sizes = new Float32Array(PARTICLE_COUNT);
      const velocities = new Float32Array(PARTICLE_COUNT * 3);

      for (let i = 0; i < PARTICLE_COUNT; i++) {
        const i3 = i * 3;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        const r = Math.pow(Math.random(), 0.6) * FIELD_SIZE;
        positions[i3]     = r * Math.sin(phi) * Math.cos(theta);
        positions[i3 + 1] = r * Math.sin(phi) * Math.sin(theta);
        positions[i3 + 2] = r * Math.cos(phi);
        const t = r / FIELD_SIZE;
        const color = new THREE.Color();
        if (t < 0.33) color.lerpColors(COLOR_B, COLOR_D, t / 0.33);
        else if (t < 0.66) color.lerpColors(COLOR_D, COLOR_C, (t - 0.33) / 0.33);
        else color.lerpColors(COLOR_C, COLOR_A, (t - 0.66) / 0.33);
        colors[i3] = color.r; colors[i3+1] = color.g; colors[i3+2] = color.b;
        sizes[i] = Math.random() * 3 + 0.5;
        velocities[i3] = (Math.random()-0.5)*0.01;
        velocities[i3+1] = (Math.random()-0.5)*0.01;
        velocities[i3+2] = (Math.random()-0.5)*0.01;
      }

      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

      const particleMaterial = new THREE.ShaderMaterial({
        uniforms: {
          uTime: { value: 0 },
          uMouse: { value: new THREE.Vector2(0, 0) },
          uPixelRatio: { value: Math.min(window.devicePixelRatio, 2) },
        },
        vertexShader: `
          uniform float uTime;
          uniform vec2 uMouse;
          uniform float uPixelRatio;
          attribute float size;
          attribute vec3 color;
          varying vec3 vColor;
          varying float vAlpha;
          vec3 mod289(vec3 x){return x-floor(x*(1.0/289.0))*289.0;}
          vec4 mod289(vec4 x){return x-floor(x*(1.0/289.0))*289.0;}
          vec4 permute(vec4 x){return mod289(((x*34.0)+1.0)*x);}
          vec4 taylorInvSqrt(vec4 r){return 1.79284291400159-0.85373472095314*r;}
          float snoise(vec3 v){
            const vec2 C=vec2(1.0/6.0,1.0/3.0);const vec4 D=vec4(0.0,0.5,1.0,2.0);
            vec3 i=floor(v+dot(v,C.yyy));vec3 x0=v-i+dot(i,C.xxx);
            vec3 g=step(x0.yzx,x0.xyz);vec3 l=1.0-g;
            vec3 i1=min(g.xyz,l.zxy);vec3 i2=max(g.xyz,l.zxy);
            vec3 x1=x0-i1+C.xxx;vec3 x2=x0-i2+C.yyy;vec3 x3=x0-D.yyy;
            i=mod289(i);
            vec4 p=permute(permute(permute(i.z+vec4(0.0,i1.z,i2.z,1.0))+i.y+vec4(0.0,i1.y,i2.y,1.0))+i.x+vec4(0.0,i1.x,i2.x,1.0));
            float n_=0.142857142857;vec3 ns=n_*D.wyz-D.xzx;
            vec4 j=p-49.0*floor(p*ns.z*ns.z);vec4 x_=floor(j*ns.z);vec4 y_=floor(j-7.0*x_);
            vec4 x=x_*ns.x+ns.yyyy;vec4 y=y_*ns.x+ns.yyyy;vec4 h=1.0-abs(x)-abs(y);
            vec4 b0=vec4(x.xy,y.xy);vec4 b1=vec4(x.zw,y.zw);
            vec4 s0=floor(b0)*2.0+1.0;vec4 s1=floor(b1)*2.0+1.0;
            vec4 sh=-step(h,vec4(0.0));
            vec4 a0=b0.xzyw+s0.xzyw*sh.xxyy;vec4 a1=b1.xzyw+s1.xzyw*sh.zzww;
            vec3 p0=vec3(a0.xy,h.x);vec3 p1=vec3(a0.zw,h.y);vec3 p2=vec3(a1.xy,h.z);vec3 p3=vec3(a1.zw,h.w);
            vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));
            p0*=norm.x;p1*=norm.y;p2*=norm.z;p3*=norm.w;
            vec4 m=max(0.6-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.0);m=m*m;
            return 42.0*dot(m*m,vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3)));
          }
          void main(){
            vColor=color;
            float t=uTime*0.15;
            vec3 pos=position;
            float nx=snoise(pos*0.08+t);float ny=snoise(pos*0.08+t+100.0);float nz=snoise(pos*0.08+t+200.0);
            pos+=vec3(nx,ny,nz)*2.5;
            vec4 mvPos=modelViewMatrix*vec4(pos,1.0);
            vec2 screenPos=mvPos.xy/-mvPos.z;
            float mouseDist=length(screenPos-uMouse*1.5);
            float mouseForce=smoothstep(1.2,0.0,mouseDist)*3.0;
            pos.x+=(screenPos.x-uMouse.x)*mouseForce*0.8;
            pos.y+=(screenPos.y-uMouse.y)*mouseForce*0.8;
            pos.z+=mouseForce*1.5;
            float breath=sin(uTime*0.3+length(position)*0.1)*0.5+0.5;
            pos*=1.0+breath*0.05;
            gl_Position=projectionMatrix*modelViewMatrix*vec4(pos,1.0);
            float dist=length(mvPos.xyz);
            gl_PointSize=size*uPixelRatio*(8.0/dist);
            vAlpha=smoothstep(50.0,5.0,dist)*(0.35+mouseForce*0.35);
            vAlpha*=0.35+breath*0.25;
          }
        `,
        fragmentShader: `
          varying vec3 vColor;
          varying float vAlpha;
          void main(){
            vec2 center=gl_PointCoord-0.5;
            float dist=length(center);
            float alpha=smoothstep(0.5,0.05,dist);
            float core=exp(-dist*6.0)*0.4;
            gl_FragColor=vec4(vColor,(alpha+core)*vAlpha);
          }
        `,
        transparent: true,
        blending: THREE.NormalBlending,
        depthWrite: false,
      });

      const particles = new THREE.Points(geometry, particleMaterial);
      scene.add(particles);

      // Orbital rings
      function createRing(radius, segments, color, opacity) {
        const geo = new THREE.BufferGeometry();
        const pos = new Float32Array(segments * 3);
        for (let i = 0; i < segments; i++) {
          const a = (i / segments) * Math.PI * 2;
          pos[i*3] = Math.cos(a)*radius; pos[i*3+1] = Math.sin(a)*radius; pos[i*3+2] = 0;
        }
        geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
        return new THREE.LineLoop(geo, new THREE.LineBasicMaterial({ color, transparent: true, opacity }));
      }
      const ring1 = createRing(12, 128, 0x5555ff, 0.1);
      ring1.rotation.x = Math.PI*0.4; ring1.rotation.y = Math.PI*0.2;
      scene.add(ring1);
      const ring2 = createRing(15, 128, 0x3333cc, 0.06);
      ring2.rotation.x = Math.PI*0.6; ring2.rotation.z = Math.PI*0.3;
      scene.add(ring2);
      const ring3 = createRing(9, 64, 0xffffff, 0.05);
      ring3.rotation.x = Math.PI*0.15; ring3.rotation.y = Math.PI*0.7;
      scene.add(ring3);

      const clock = new THREE.Clock();

      function animate() {
        requestAnimationFrame(animate);
        const elapsed = clock.getElapsedTime();
        mouse.x += (mouse.targetX - mouse.x) * 0.05;
        mouse.y += (mouse.targetY - mouse.y) * 0.05;
        particleMaterial.uniforms.uTime.value = elapsed;
        particleMaterial.uniforms.uMouse.value.set(mouse.x, mouse.y);
        particles.rotation.y = elapsed * 0.02;
        particles.rotation.x = Math.sin(elapsed * 0.01) * 0.1;
        sphere.rotation.y = elapsed * 0.05;
        ring1.rotation.z = elapsed * 0.05;
        ring2.rotation.z = -elapsed * 0.03;
        ring3.rotation.z = elapsed * 0.07;
        camera.position.x = Math.sin(elapsed * 0.08) * 1.5 + mouse.x * 2;
        camera.position.y = Math.cos(elapsed * 0.06) * 1 + mouse.y * 1.5;
        camera.lookAt(0, 0, 0);
        renderer.render(scene, camera);
      }
      animate();

      // Click burst (listen on document, canvas stays pointer-events:none)
      document.addEventListener('click', (e) => {
        const posArray = geometry.attributes.position.array;
        const bc = new THREE.Vector3(
          (e.clientX/window.innerWidth*2-1)*15,
          (-(e.clientY/window.innerHeight)*2+1)*10, 0
        );
        for (let i = 0; i < PARTICLE_COUNT; i++) {
          const i3 = i*3;
          const dx=posArray[i3]-bc.x, dy=posArray[i3+1]-bc.y, dz=posArray[i3+2]-bc.z;
          const dist=Math.sqrt(dx*dx+dy*dy+dz*dz);
          if (dist < 8) {
            const force=(1-dist/8)*4;
            velocities[i3]+=(dx/dist)*force*0.3;
            velocities[i3+1]+=(dy/dist)*force*0.3;
            velocities[i3+2]+=(dz/dist)*force*0.3;
          }
        }
      });

      function updatePositions() {
        const posArray = geometry.attributes.position.array;
        for (let i = 0; i < PARTICLE_COUNT; i++) {
          const i3 = i*3;
          posArray[i3]+=velocities[i3]; posArray[i3+1]+=velocities[i3+1]; posArray[i3+2]+=velocities[i3+2];
          velocities[i3]*=0.96; velocities[i3+1]*=0.96; velocities[i3+2]*=0.96;
        }
        geometry.attributes.position.needsUpdate = true;
        requestAnimationFrame(updatePositions);
      }
      updatePositions();

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        particleMaterial.uniforms.uPixelRatio.value = Math.min(window.devicePixelRatio, 2);
      });
    })();
  </script>
</body>
</html>
